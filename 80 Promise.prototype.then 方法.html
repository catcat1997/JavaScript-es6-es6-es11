<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 創建promise對象
        const p = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('用戶數據');
                // reject('出錯啦');
            }, 1000);
        });

        // 調用 then方法   then方法的返回結果是 Promise對象,對象狀態由回調函數的執行結果決定
        // 1.如果回調函數中返回的結果是 非Promise類型的屬性, 狀態會為成功,返回值為對象的成功值
        const result = p.then((value) => {
            console.log(value);
            // 1.返回結果是非Promise類型的屬性
            // return 123;
            // 2.返回結果是Promise 對象
            // return new Promise((resolve, reject) => {
            //     resolve('ok'); // fulfilled 是promise的一種成功狀態
            //     // reject('error');
            // });
            // 3. throw出錯誤  PromiseState為 "rejected"
            // throw new Error('出錯啦!');
            // throw '出錯啦!';
        }, (reason) => {
            console.warn(reason);
        });

        // 鏈式調用 then   鏈式可以解決 回調地獄的問題
        // p.then((value) => {}, (reason) => {}).then((value) => {}, (reason) => {});
        console.log(result);
    </script>
</body>

</html>